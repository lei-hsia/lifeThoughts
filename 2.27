昨天的137. Single Number II:实际上是位运算的题;
        外层的for i循环是对每一位进行处理,每次处理就处理完; 内层的for j是遍历数组处理每个数的每一位对3取余得到结果;
        每一位上面处理完成之后左移i位, 完成32位得到最后要的那个数
260. Single Number III: 
     对位运算很细致的应用了: 首先对所有的数进行累积位运算,得到的一定是两个只出现一次的数位运算的结果diff;
     diff再取相反数-diff跟自己XOR, 得到的位上面是1的就是这两个不同的数区分开来的方法: 因为相同的数每一位
     异或都是得到0, 不同的数才得到1, 这两个数也有位的不同，所以就分开了, 然后对这两个数组进行 Single Number I
     的所有数异或操作
   c++: std::accumulate(iterBegin, iterEnd, T init, BitOperation binary_op): 
          iterBegin到iterEnd之间的数都累加到init上
          
### reverse linked list这类题, 图画出来 ###
24. Swap Nodes in Pairs: 
      linked list反转的这类题， 反转都是从后往前安排好，因为如果先安排前面的，反转的时候后面没办法了；
      1. 每一个单位内，从后往前安排好(这里是pair数);
      2. 然后pre的next指向下一个单位的开头继续
      3. while循环知道要用的指针都不能用了
      ⚠️⚠️注意: 创建两个不同的指针的区别: 
           1. ListNode *dummy = new ListNode(-1); // 创建了一个node对象, dummy是指向这个不变的对象的指针;
           2. ListNode *pre = dummy; // 只是创建了一个指针, pre可以变化
    上面是迭代的思路, 如果是递归的思路就用到了回溯法: 类似于一个stack逐渐往下, 再逐渐往上恢复的时候是相反的方向

12. Integer to Roman: GREEDY
    e.g. 1437->MCDXXXVII:做法很明显应该是取每一位上面的数字:取商法,然后每一位上面的数表示出来;
    从大到小取的话, 要把大的取完再取小的: greedy
    注意数字的列表中只有1,4,5,9,10,40,50...因为2和3都可以用1表示,并不特殊
    
13. Roman to Integer: HASHMAP
    我想到了是有相邻的字母成块的这种情况，但是怎么转化成数字??
    实际上成块的相邻字母总是后面的字母大于前面的; 前面的字母这个时候实际上是减去了这个字母代表的数字大小;
    那么,因为从前往后的字母顺序是从大到小的, 那么这个代表要减掉的字母肯定也是小于前面的字母代表的数字的==>
    碰到最后一个字母或者这个字母大于后面字母代表的数字才加，否则应该减掉 
    
