https://www.jianshu.com/p/d52fea0d6ba5

当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，
也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为
都可以获取正确的结果，那这个对象是线程安全的。   --- 《深入理解Java虚拟机》

出现线程安全的问题一般是因为****** 主内存和工作内存数据不一致性和重排序导致的******，
而解决线程安全的问题最重要的就是理解这两种问题是怎么来的，那么，理解它们的核心在于
理解java内存模型（JMM）。

在多线程条件下，多个线程肯定会相互协作完成一件事情，一般来说就会涉及到多个线程间
相互通信告知彼此的状态以及当前的执行结果等，另外，为了性能优化，还会涉及到
编译器指令重排序和处理器指令重排序

线程通信: 2种方式: 1.写纸条让吃饭-->共享内存; 2.手机有电打电话-->通知机制;

1. 共享变量: 都在堆内存: 哪些是共享变量: 所有的 **实例域, 静态域, 数组元素** (跟着类走，存在堆内存中的);
      而存在栈内存中的: 局部变量,方法定义参数,异常处理器参数不会在线程间共享;

2. 内存的来源: CPU自己的缓存:<--因为CPU处理速度和主存的读写速度差异巨大
JMM:         线程A          线程B
              |              |
              |              |
            本地内存A      本地内存B
          (共享变量的副本)  (共享变量的副本)
              |               |
              | <--JMM控制-->  |
              |               |
              V               V
                主内存(共享变量)
共享变量先存在主内存中，每个线程都有属于自己的工作内存, 并且会把主内存的共享变量拷贝到自己的工作内存，之后读写都是自己的工作
内存的变量副本，并在某个时刻将工作内存的变量副本写回到主内存中; JMM从抽象层次定义了这种方式, 并且JMM决定了一个线程对共享变量
的写入何时对其他线程是可见的;
(内存的可见性问题)
如果A更新数据没有及时写回主内存，而线程B读到的是过期的数据: 就出现了"脏读"现象: 
可以通过同步机制(控制不同线程间操作发生的相对顺序), 或者通过volatile关键字使得volatile变量每次写都强制刷新到主存,
从而对每个线程都是可见的;  

3. 重排序:       (compiler reorder)      (processor reorder)
   source code-->编译器优化的重排序->指令级并行的重排序->内存系统的重排序->最终执行的指令顺序;
   
   如果两个操作访问同一个变量，且这两个操作有一个为写操作，此时这两个操作就存在数据依赖性
   编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序
   
 as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提供并行度），（单线程）程序的执行结果不能被改变
   
JMM为程序员在上层提供了六条规则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则
JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证
  happen-before && as-if-serial: 本质上语义是一回事:即在程序执行语义结果不变的情况下,执行顺序改变与否无关;
as-if-serial VS happen-before:
1. as-if-serial保证了单线程程序执行结果不变, happen-before保证了多线程程序执行结果不变;
2. as-if-serial给单线程程序员创造了程序是按写的顺序执行的，happen-before给正确同步的多线程程序员创造了程序是按happen-before指定顺序执行的
3. as-if-serial && happen-before这样做都是为了在不改变结果的前提下提高程序执行的并行度
==> 但是: 如果两个操作不存在数据依赖性, 那么两个前后的操作可以重排序--> happen-before关系不代表最终执行顺序









   
   
   
   
