542. 01 matrix:  
    每个cell往外扩散找到当前cell的最近的0: 一层一层往外扩散: bfs; 
    
    解法1: queue: 存的都是0: 所有的0都存进queue作为起点开始遍历4个方向,更新旁边的cell;
          遍历矩阵0还是0，1改成INT_MAX;  queue: 0存进来, 每个0都是起点; queue中取数字遍历4个方向;
          如果越界或者周围的值小于等于当前的值加1，就不要更新, 跳过: 因为根据当前的值更新最小都是当前的值+1;
          否则周围的值大于当前的值+1: 更新周围的值 = 当前值+1;
          
    解法2: 二次扫描：
          res矩阵: 和当前矩阵结构相同,全部初始化为INT_MAX-1: 首先matrix的cell为0的res中也赋值为0；
          然后第一次遍历res: 只是比较左上方
          
          本来每个cell都要扫描4个方向, 现在两次遍历: 首先遍历左上方: 因为这也是正常的方向：当前cell的左上方一定遍历过了;
          用 (左上方的较小值+1) 来更新当前的cell的值；<--- 这里就能看出为什么res初始化是用 INT_MAX-1: 因为要+1;
          
          过了一遍之后，一定没有跟INT_MAX相关的值了: 全部都是很小的自然数: 然后从右下方开始遍历,不过如果当前的cell值是
          0或者1就不用更新当前cell值: 因为0那么就是0，1表明旁边有0: 也不用更新
  >>>>>
  其实由 #Enclaves 和这道题很容易看出dfs, bfs的区别: 
      enclaves: cell要一条路往下走: 看能不能走到边界上; <---- dfs;
      01 matrix: cell跟周围的4个位置上的值相关,相邻更新 <---- bfs;
  
