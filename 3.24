昨天的contest改正: 
Partition Array into 3 parts w. Equal Sum:     
      均分为3部分，每部分和应该就是 sum/3;
      既然用left/right双指针确定切割点既没有必要而且两者的顺序会影响最后的结果: 用temp记录累加
      得到的和---作为一个流量计:满了sum/3就重置为0而且用count计数有多少个这种部分:最后count>=3✅
      (count>=3而不是count==3, 因为如果sum是0那么可以多次达到0并不一定就是3次)

Smallest Integer Divisible by K:
     1. 如果记录111111...这个数本身会撑爆: 每次的余数保存下来, *10+1得到下一个数再除K；
        i.e. 每次都是存mod之后的结果, 而不是那个数; 那个数是多少其实也不重要 
     2. 因为数很大, *, 取余都是变为了 O(logN),而不是O(1);
     3. 本身的数每次是 *10+1的关系，那么余数也是 *10+1的关系;
     4. 循环暴力查找为什么是次数循环到K就行了? 
        A: 因为一开始排除了整除2/5的情况; 之后从1-->K查找,除K的余数:这K个数有K个余数, 但是整除K的余数
        一共有1,...K-1种可能性, 所以由鸽巢原理必定存在至少两个数, mod K 之后得到的余数相同;
        一旦余数出现了duplicates, 那么111...1这种数不可能出现能被K整除的数了; 因为一旦出现相同的余数a，下一个数
        会进入一个从a开始的余数的循环<---因为上次的余数决定了本次的余数，所以不可能出现整除K的1111...这样的数了
     5. ===>
        所以循环暴力查找终止条件的上界并不是10^5, 而是可以缩小到 K
 
Best Sightseeing Pair:
    最直接的方法就是max{A[i]+A[j]+i-j}; 跟题目描述的一样; 
    遍历数组一次(如果是两次就TLE): 
    更新条件: 因为前面一个index对应的数和index是相加的:i.e. A[i]+i; 
    所以更新条件是:如果之前存的 (数+index)pair < (当前的数+index)pair: prevIndex = i;
  ===> 
     数组的题，如果是考题，大部分都是one-pass;
     
Binary String w. Substrings representing 1 to N:
   S是二进制字符串, N是给定的数字;
   1<= S.length <=1000: 说明其实N不能很大: 
   解法: 直接判断S是不是包含了N的二进制, 如果不包含直接返回false; 包含就往下查N-1, etc.
   从N开始到1是因为先找长的二进制substring是不是包含了逐渐到简单的: 这样可以尽早结束,降低时间复杂度;
   S的构建是一个NP的问题(这里实际上是一个最小路径问题);
   
   S看有没有跟N的二进制string相同的substring: 实际上是S中选两个index组成substring: O(S.length^2)
   循环是到 i>N/2 不用到1: 因为i<N/2的部分, 2*i都包含了i的二进制string(就是在i的二进制string前面加一个1)
