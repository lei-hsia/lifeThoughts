周末做了contest, 没有做新题

把contest的题目弄清楚:

1002. Find Common Characters: 如何得到所有单词都共有的letter? 
      遍历数组, 对每一个string, 记录字母出现的频数的数组, ⚠️注意这个数组是遍历一个单词就创建一个，
      也就是说每个数组都只记录一个单词所有字母的频数, 每次都更新cnt[i]=min(cnt[i], cnt1[i]);
      这样相当于当前的最小频数数组cnt记录了到目前位置为止global最小频数数组: 是一个单词一个单词比较出来的;
      最后得到的一定是所有单词都具有的最小频数;
   ❌: 如果是所有string都遍历一遍得到cnt1, 这样是所有的string的频数都累加了,再cnt[i]=min(cnt[i], cnt1[i])
   的话就一定有cnt==cnt1; 并没有任何用处
   附: 
      string类的构造函数:   string(int n, char c); // 用n个字符c初始化
   🈴️核心: 每个temp数组实际上只是记录了一个string对应的char的频数
   
1003. Check if Word is Valid After Substitutions: 
     因为是: 1. 不想关注index: 不用vector;
            2. abc要保持相对顺序但是并不一定全部要相连:可以本来不相连除掉相连的abc剩下的相连; 
               一旦有了abc就丢掉: 用stack
              而且这个stack只是要碰到'c'就把前面的'a', 'b'都连着丢掉,所以要达到这个目的, 用vector都可以

1004. Max Consecutive Ones III: 已经想到了sliding window, 但是关注点放在1上面了,而实际上
      应该是关注0: 从1开始可以要改动1前面的0而且不知道有多少个, 所以并不能从1开始; 从前往后滑动
      如果K仍然>0, 就把0变为1, 当K变为<0时， 判断左边界是不是0, 如果不是0可能就可以当作连续1的部分,
      否则是0就肯定不能, 此时滑动窗口左边界increment; 因为之前改变左边界的0花掉了K的1个，所以++K补偿回去
      
   为什么K不用resume变为初始值? 因为改变的部分其实只有左右边界, 中间的部分都已经过了一遍了, 所以其实只用
   改变因为之前0变为1花掉的K中的1
   
1000. 
