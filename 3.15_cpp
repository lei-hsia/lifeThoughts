cpp 多态实现和virtual:  https://www.jianshu.com/p/c8e74ef95091 

类的多态性用一句话概括就是：在基类的函数前加上virtual关键字，在派生类中重写该函数，
运行时将会根据对象的实际类型来调用相应的函数   (其实核心是指针指向的对象类型的地址)
如果没有virtual, 编译器要求指针指向的对象early binding: 在编译的时候指针就绑定对象的地址,
此时的指针是父类的类型, 
fish fn;
*pAn = &fn; 

从编译的角度
C++编译器在编译的时候，要确定每个对象调用的函数的地址，这称为早期绑定（early binding），
当我们将fish类的对象fh的地址赋给pAn时，****** C++编译器进行了类型转换 *******
此时C++编译器认为变量pAn保存的就是animal对象的地址。当在main()函数中执行pAn->breathe()时，
调用的当然就是animal对象的breathe函数。

从内存模型的角度
我们构造fish类的对象时，首先要调用animal类的构造函数去构造animal类的对象，
然后才调用fish类的构造函数完成自身部分的构造，从而拼接出一个完整的fish对象。
当我们将fish类的对象转换为animal类型时，该对象就被认为是原对象整个内存模型的上半部分，
也就是图1-1中的“animal的对象所占内存”。那么当我们利用类型转换后的对象指针去调用它的方法时，
当然也就是调用它所在的内存中的方法。因此，输出animal breathe，也就顺理成章了。

要想得到我们想要的结果就要使用虚函数
前面输出的结果是因为编译器在编译的时候，就已经确定了对象调用的函数的地址，要解决这个问题就要使用
迟绑定（late binding）技术。当编译器使用迟绑定时，就会在运行时再去确定对象的类型以及正确的调用函数。
而要让编译器采用迟绑定，就要在基类中声明函数时使用virtual关键字，这样的函数我们称为虚函数。
一旦某个函数在基类中声明为virtual，那么在所有的派生类中该函数都是virtual，而不需要再显式地声明为virtual

virtual VS pure virtual: 
1. 虚函数和纯虚函数可以定义在同一个类(class)中，含有纯虚函数的类被称为抽象类(abstract class)，
    而只含有虚函数的类(class)不能被称为抽象类(abstract class)。
2. 虚函数可以被直接使用，也可以被子类(sub class)重载以后以多态的形式调用，
   而纯虚函数必须在子类(sub class)中实现该函数才可以使用，因为纯虚函数在基类(base class)只有声明而没有定义。
3. 虚函数和纯虚函数都可以在子类(sub class)中被重载，以多态的形式被调用。
4. 虚函数和纯虚函数通常存在于抽象基类(abstract base class -ABC)之中，被继承的子类重载，目的是提供一个统一的接口。
5. 虚函数的定义形式：virtual {method body}
   纯虚函数的定义形式：virtual { } = 0;
6. 在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时候要求前期bind,
    然而虚函数却是动态绑定(run-time bind)，而且被两者修饰的函数生命周期(life recycle)也不一样。

7. 虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。

8. 多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。
   C++支持两种多态性：编译时多态性，运行时多态性。
     a.编译时多态性：通过重载函数实现
     b 运行时多态性：通过虚函数实现

作者：安然_fc00
链接：https://www.jianshu.com/p/c8e74ef95091
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。
