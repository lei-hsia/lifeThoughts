(E)
172. Factorial Trailing Zeroes: trailing: left behind, 是找这个数的末尾的0的个数,
     也就是乘数中的10的个数; 10=2*5,而乘数中的每个数因式分解2的个数远大于5的个数,所以变为
     找5的个数; 不过像25，125这种因式分解不止含有一个5的数要考虑进去;
  ⚠️注意: 实际上根本用不着算阶乘的结果, 遍历每一个乘数看因式分解得到什么就可以了;
 
(E)
125. Valid Palindrome:  回文字符串 : 用 Manacher算法,或者左右双指针向中间夹击

    (s[left] + 32 - 'a') %32 != (s[right] + 32 - 'a') % 32 // 不区分大小写,统一处理
    如果是大写字母+32变为对应的小写字母-'a'得到对于'a'的相对位置, 因为结果肯定是小于32的所以%没关系;
    如果是小写字母还是得到对应'a'的相对位置，对32取余变为相同:  
    
  ⚠️注意: 主要是要对32取余: 这样才能不区分大小写统一处理 (此题重点就是 1.双指针; 2.不区分大小写统一处理的方法)
  
(E)
680. Valid Palindrome II:
     最多删一个: 那么碰到不相等的: 删左边的还是右边的?: 两种都要算一遍;
     用一个函数专门判断是不是palindrome:传递的参数是s的子串两边的index: 因为此时的left,right都已经向中间走了一段了,
     所以实际上 (left, right-1)/(left+1, right)就是前面判断完了之后接着判断剩下没有判断的部分;
    :::
      isValid(string s, int left, int right): 判断给定的string是不是严格的palindrome;
      validPalindrome(string s): 调用了isValid(), 是删掉了一个char之后接着判断是不是palindrome
*********************************
          DFS: vertical: stack;
          BFS: horizontal: queue;
*********************************
(M)
127. Word Ladder:
      1. 首先换一个字母: 应该是从当前给定的单词出发, 判断换了一个字母之后的单词是否在wordList中; 而不是直接在wordList中找;
         因为直接在wordList中找有可能给定的list很大这样遍历就很慢----而直接改变给定的单词的一个字母只有26种情况~类似迷宫
         找出口的题目; 只不过这里的迷宫变为了26个方向的迷宫，而不是4个方向的; (迷宫遍历用bfs找出口)
      
      2. ⚠️那么这样寻找一条可能的路径: dfs和bfs: dfs一条路走到黑:可能中间某个时候就已经明显不可能达到目的地了: 所以dfs不对;
          bfs: 一次只改变1个字母判断可能达到目标之后才继续向这个可能的方向走---向往水中扔石子一样按波纹往外扩大范围最终达到目标;
          水波纹碰到湖上的树叶时，那么此时水圈的半径就是圆心到树叶的最短距离
          e.g. 'hot'--> 'hpt','hqt'... (dfs)继续往下走; 
                    --> 'aot','bot'... (bfs)又重新开始, 广度优先
       
      3. 外层for: 对给的string s每个位置上的char遍历; 内层for: 选定位置之后, 把这个位置的char改成26种不同的可能;
         (初始单词的每一位都可以改变, 每个改变都有26种可能)
         每一种可能是在一行上的，放在queue中作为下一位 换char的起始单词; 
         
      4. 因为每次改变一个char，这个中间状态的temp单词都有一个伴随状态变量:即 "已经改变了多少个char到达的当前单词",这个
         int类型的变量要累计计算，最后得到的如果就是endWord:单词改变结束:对应的int变量就是要求的‘走出迷宫’用了多少步
         
  每改变一个字母: 都是同一级: 存进queue的同一层中
      
        trivial: 
        1. unordered_map带具体值的初始化: unordered_map<string, int> m({
                                             中间是2层花括号                {"apple": 1},
                                                                          {"banana": 2}
                                                                          })
        2. while (!q.empty()) {
            string word = q.front(); q.pop(); // 用bfs的queue几乎都是q非空的循环条件中第一行q.front()得到要处理的对象
        
        3. if (wordSet.count(newWord) && !pathCount.count(newWord)) 
        // 后面的条件: 只能在map中直接找,并不能在在queue中直接找; 而且这个是新产生的单词,所以queue中就算之前的层级上面有这个单词,
           还是要加到当前的层级的queue中: 因为是从另一种换字母的方式得来的:但是因为另一种层级低表示count少,所以没有意义继续朝这个
           方向往下
  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
  
  
  
  
  
