40.Combination Sum II, 通过昨天的例子, 可以看出:
    sort()之后再 if(num[i]==nums[i-1]...)可以去重
为什么 if(nums[i]==nums[i-1])可以去重？:
因为 e.g. [1,2,2,2,5], target=5; 在代码: 
if (target < 0) return;
        else if (target == 0) res.push_back(out);
        else {
            for (int i = start; i < num.size(); ++i) {
                if (i > start && num[i] == num[i - 1]) continue;
                out.push_back(num[i]);
                combinationSum2DFS(num, target - num[i], i + 1, out, res);
                out.pop_back();
                ...
中, 首先会有[1,2,2], 此时target==0, res.push_back([1,2,2]), 
然后最后一个2被pop_back()之后, 此时i++到了第三个2, 但是因为第二个2在第三个2前面,
所以1, 第一个2, 第三个2的情况并不会加进去: 这就是sort之后的好处: 
答案中有用相同的数构成的答案, 这种去重的方式保证用到相同的数的答案只会有一种情况,
后面的就算 数是不同的, 数的大小相同得到的答案也相同
-------------------------------------------
216. Combination Sum III: 从1到9的自然数选k个数总和为n的组合: 跟之前的Combination, Combination II
     相比, 注意两点: 
     1. 并不用count参数记录out中放了多少个数, 因为out.size()反应的就是out中放了多少个数
     2. 没有必要 if(i>index && nums[i]==nums[i-1]),因为nums就是自然数1-9序列,不可能有
        跟前一个数相同的情况

377. Combination Sum IV: 跟前面的combination都不同，这个限制最小可能的情况数量最多, 
                        用dfs递归会TLE, 用dp
     这题的本质实际上是"不受一步层数限制的climb stairs"
     achtung: 1. dp[i] += dp[i-j]的前提条件是if(i > j), 因为首先那一层楼梯要在跨度之上
        2. nums先排序; dp中的i如果小于nums中的数,直接break, 因为后面的nums的数更大,这样进行优化

254. Factor Combinations: locked, 但是这种求所有的vector的一个大vector的所有可能的题，
                          都是dfs/backtracking; 求所有的因子不包含1,n, 从2开始遍历,
                          如果i能被n除就把i加到out中, out中的遍历从i 到 n/i
