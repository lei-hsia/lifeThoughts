40.Combination Sum II, 通过昨天的例子, 可以看出:
    sort()之后再 if(num[i]==nums[i-1]...)可以去重
为什么 if(nums[i]==nums[i-1])可以去重？:
因为 e.g. [1,2,2,2,5], target=5; 在代码: 
if (target < 0) return;
        else if (target == 0) res.push_back(out);
        else {
            for (int i = start; i < num.size(); ++i) {
                if (i > start && num[i] == num[i - 1]) continue;
                out.push_back(num[i]);
                combinationSum2DFS(num, target - num[i], i + 1, out, res);
                out.pop_back();
                ...
中, 首先会有[1,2,2], 此时target==0, res.push_back([1,2,2]), 
然后最后一个2被pop_back()之后, 此时i++到了第三个2, 但是因为第二个2在第三个2前面,
所以1, 第一个2, 第三个2的情况并不会加进去: 这就是sort之后的好处: 
答案中有用相同的数构成的答案, 这种去重的方式保证用到相同的数的答案只会有一种情况,
后面的就算 数是不同的, 数的大小相同得到的答案也相同
-------------------------------------------
216. Combination Sum III: 从1到9的自然数选k个数总和为n的组合: 跟之前的Combination, Combination II
     相比, 注意两点: 
     1. 并不用count参数记录out中放了多少个数, 因为out.size()反应的就是out中放了多少个数
     2. 没有必要 if(i>index && nums[i]==nums[i-1]),因为nums就是自然数1-9序列,不可能有
        跟前一个数相同的情况
