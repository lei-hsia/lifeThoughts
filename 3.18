1015. Numbers w. Repeated Digits: 想到了要用N- numbers without RD;
    A(m, n)和P(m,n)是相反的方向看的, 所以A(m,n)=m*(m-1)*...*(m-n+1) = A(m,n-1)*(m-n+1); P是除掉 n!;
  
  // java: 算无重复位的正整数的个数, m=9: 已经考虑了首位不能为0; 
  // n表示位数,e.g. P(9,3)表示9*8*7
  public int A(int m, int n) {
        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);
    }
用HashSet是便于判断有没有相同的数:contains(); seen这个set是等当前数位给定的加了所有不重复数个数之后，加入的就是给定的数的当前位;
比这个数小的前面所有不重复的都数进去了, e.g. 当前是8,之前1-7开头的数都过了一遍; 8现在加入set那么后面的数不能有8, 换一种想法相当于
后面的数都相当于8开头了; 

j实际上表示的是当前这个位置上面的数能是哪些数; i对应的是当前的数位是哪个位置;

if(seen.contains(L.get(i)) break; break条件: e.g. 737802: 737固定了,那么后面不管怎么样,因为前面有重复的7所以不管怎么样都是有重复:break;

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
这道题想起来不难，但是相当的难写啊

similar: 
788. Rotated Digits: 0,1,8即使翻转之后还是自己本身，但是如果有翻转之后不是自己的数，那么就算0,1,8
    保持不变这个数字也改变了;
   如果单看给定的N的每一位数: 0,1,8没有什么卵用:不管;
                          3,4,7不能旋转，所以只要出现，那么旋转之后当前的数就是invalid: 直接return false;
                          2,5,6,9有就满足:遍历数的位数看有没有2569其中的一个;
