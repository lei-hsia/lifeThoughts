今天先刷题再复习c++; 明天开始主java;

TODO: skyline, 76, candy crash; ...

15. 3Sum: sort, fix1, left/right指针后两个; 相同数就跳过
(⚠️:sort,判断相邻是否相等, 双指针)

16. 3Sum Closest:
    不需要fast lane, 因为每个都要比; sum跟target要算diff: 初始化一个diff然后每得到新的三个数再得到newDiff; 
    比较diff和newDiff从而更新diff; sum最后的最小值就赋值给了closest; // closest和diff的初始值就是简单的最开始
    的三个数得到的;
    
923. 3Sum w. Multiplicity: 用3sum的思路为什么不对？？ 

*********** 下午上课: 竟然讲到了template class模版类; 真是没有想到; ***********

(这个题是一个很好的题)
218. Skyline problem: 
很重要的思想: ⚠️把左边和右边拆开看===> 
        每个矩形说白了变成了左边和右边两根竖线; 那么遍历获得左边竖线的顶点: 因为并不会因为当前建筑矮一些就没有棱角了:
        矮一些也会有棱角: 所以这个顶点只要是不跟前面一个同样高度那么这个顶点都应该加到结果中; 然后每次遍历到右边竖线
        表示已经过了这个建筑的覆盖范围: 那么就要在记录有多少建筑在的这个容器中删除当前建筑;
  很重要的地方: 
      cur = *m.rbegin();
      if (cur != pre) {... pre=cur; }
  🐒⚠️---> 因为m是multiset是排序的: 所以m.rbegin()取出来的一定是历史记录中还没有碰到这个建筑右边界的最高建筑高度;
    ⚠️---> 这也是怎么解决在高建筑覆盖的区间: 不加矮的建筑的左边界竖线的办法; 当高建筑到达右边界之后出了右边界就没有关系了
   一开始:m中插入0: 因为当碰到右边界没有和别的建筑重合的时候那么这个右边界落脚点也是要加进res的,此时高度是0
  相对不那么重要的trivial:
     1.左右竖线要区分开来:用正数和负数的高度来表示; 
     2.容器记载到目前为止cover了多少个建筑, 因为可以有多个高度相同的建筑所以不用set而用multiset;
     3.⚠️另外注意的就是sort函数: 不管是单个还是pair之类的类型,不专门指明什么类型那么就是按元素的第一个数从小到大排序
     4. map/set: find()返回值是迭代器参数是要找的值: iterator find (const value_type& val) const;
     5. erase(): 参数传递的是一个value或者迭代器
     
