有一个二进制的mask, 产生所有的subsets的方法: 

1. for i = 0 to 1 << n
  
```
for (int i = 0; i < (1 << l); ++i) {
    int mask = 1 << (p[0] - 'a');
    for (int j = 0; j < l; ++j) {
        if (i & (1 << j)) mask |= 1 << (p[j+1] - 'a');
    }
    auto it = freq.find(mask);
    if (it != freq.end()) total += it->second;
}
```
```1 << j```: 每次左移j, 得到所有的subsets, 这种方法每次都要做操作, 所以并不是很高效

2. #### i = (i-1) & x (x is the bitmap)

i = x开始

```
i           i-1           (i-1) & x, x = 1101  (选中第1,3,4个字母)
1101        1100          1100
1100        1011          1001
1001        1000          1000
1000        0111          0101
0101        0100          0100
0100        0011          0001
0001        0000          0000
```
这样也可以得到所有的subsets.
#### 实话说, 我之前并没有见过用```(i-1) & x```这种方法得到所有的subsets的做法. 这样因为每次都只是减1，所以效率最高
