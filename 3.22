(E)
119. Pascal's Triangle II:
    O(k) space: 把杨辉三角写成不是金字塔型，而是矩形的左下部分: 
    可以看出当前的数都是上面的位置的数加上前面一个位置的数: 用i表示行数循环, j表示每一行中的当前位置的数,
    j在i的循环体中刚好每次都是 res[j]=res[j]+res[j-1]: 因为循环的过程中j是往下的,所以等号右边的j就是上面一行相同位置的数;
    分解成为两个数之和，除了每一行的第一个和最后一个数都是可以的;
    
Moore Voting:------------------
(E)
169. Majority Element: 直观: map, sort; 
    另一种是用一种叫摩尔投票法 Moore Voting，需要O(n)的时间和O(1)的空间，比前一种方法更好。
    这种投票法先将第一个数字假设为众数，然后把计数器设为1，比较下一个数和此数是否相等，
    若相等则计数器加一，反之减一
    ==> 为什么: if(count==0) res=num; <---num从上一次的第一个数到第二个数,etc.而是能够跳跃的:
               只要count为零了, num是当前的数赋值给res: 这样是因为index并不重要,如果是很多的数
               就是当前的num, 所以num直接赋值;
    
(M)
229. Majority Element II:
     严格限定了时间和空间复杂度，所以就只能用 Moore Voting的方法了:遍历当前数组用count计数当前的数出现的次数;
     碰到 相同的数/不同的数--> 对应++count/--count;  因为这道题并没有说一定存在
     所以找到两个candidates之后还要验证----> 因为上面找到的只是加减之后仍然是正数的数,并不一定就是频率>n/3
     trivial:
              else if (cm==0) m=i, cm=1;  // if一行,操作用 , 隔开是可以的
              cm = cn = 0;  // 连等是可以的
       java: array: length是属性不是方法
--------------------------------
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
(M)  旋转图片: 非常实用: 是计算机中经常用的方法
48. Rotate Image: 其实是看不同的翻转方式: 
    1. 最简单: 先得到原来的矩阵的转置矩阵, 然后每一行倒序: 
          1 2 3        1 4 7        7 4 1
          4 5 6  --->  2 5 8  --->  8 5 2
          7 8 9        3 6 9        9 6 3
     转置: for (int i=0; i<n; ++i) {                  // i: 0->n-1; j: i+1->n-1: 实际上是取右上半部分所有元素,
            for (int j=i+1; j<n; ++j) {              // 准备和左下半部分的所有元素交换
                swap(matrix[i][j], matrix[j][i]);
                
    void reverse(BidirectionalIter first, BidirectionalIter last); 
    
    2. 还可以4个元素4个元素地旋转: 首先是4个定点的元素, 然后是4条边上中间的元素;---> 但是还是要数每个index是多少:麻烦不少
            
723. Candy Crush: 
      1. 所有能被消除的全部同时消除(simutaneously):减少了能消除的先后消除结果不同这个麻烦;
      2. 横纵方向上 >=3 才能被消除: 所以 islands那道题的找联通区域的方法不好: 因为可能就只有2个;
      3. board这类题, base方法就是一个格子一个格子看: 大不了就看当前的格子是否可能被消除:能被消除就标记出来,
         board遍历完了就同时一起消除; 标准是看 当前格子十字延伸3个格子有没有3个相同的连在一起的
      
      // 判断3个相连: x0>i-3; 而不是x0>=i-3; 因为从本位置开始,判断自己算一个<--实际上没有什么用;
      // 然后--x0再带入while判断: 也就是说其实是先减一次再while判断的; 那么减2次变为i-2就已经出现
      // 了3个相连的位置:不应该继续往下减了; 如果写的是 x0>=i-3: 多减了一次;
      // 因为board[x0][j] == board[i][j]: 所以 x1-x0: 一定都是连着的
      while (x0 >= 0 && x0 > i - 3 && board[x0][j] == board[i][j]) --x0;
       
            
            
