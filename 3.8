等待池和锁池; wait/notify/notifyAll~synchronized; bash之awk; java中的容器泛型,多态和通配符: 见3.8今天的伴随file


LC:继续哈希表
599. Minimum Index Sum o 2 Lists: 2个list一般都是只用一个哈希表建立其中一个的映射关系再遍历另一个list;
         这样比用两个哈希表然后用迭代器遍历哈希表高效:==> 因为其实不需要知道出现的和是2，只需要知道一个中有,遍历另一个的时候也有
      else if(sum<mn) mn=sum; res={list2[i]}: 重置了res, 
      此时的res只包含了两个index和最小的string, 相当于强力的高index对应的string的pop_back()
     map存的就是list1中的string对应的index
  
***🇨🇳重要:***********************

692. Top K Frequent Words:
     PQ/min heap: 默认的PQ是由 Min-heap实现的; 而"heap"这种数据结构是底层为PQ的最优结构
   : Grandyang的思路: cmp:(...&a, ...&b) ..return a.second>b.second: a大于b=>频率小的排在前面;
     因为如果是a.second<b.second就是a的频率小a排在前面;这里a>b所以a排在后面;也就是这个PQ实现了频率小的
     在前面; 
     ⚠️: 通用思路: 如果实现只保留K个元素在PQ中？ PQ相当于一个pipe: 一边进一边出:因为PQ存的是pair,
     而且pair就是string和出现的频率, PQ存的是从小到大排序的pair, pair元素个数超过了K就从top处pop==>
     所以堆顶pop出去的总是频率小的pair,那么最后剩下的就是从小到大的最多的K个pair; 然后从头到尾遍历从后
     往前插入res中就行了
  关键:实现的最小堆能按照从小到大的频率排序; string因为有个数这个伴随状态int: 用pair记录
 🇨🇳: 只要是有 top k...的这种, 都是用PQ解决
     PQ: 本来是按照频率从大到小排序的; 自定义Comparator: a.second>b.second: 就变成了频率从小到大排序: >的在后面;
     sort 相反:本来是从小到大排序, 如果 a.second>b.second: 变成了从大到小排序
  PQ: a.second > b.second: 频率大的排在后面;
         a.first < b.first: 字母顺序大的排在**前面** <---?????
   
   方法二: 实在不懂就用map: map是从小到大排序的; set默认也是升序排序的: 词频的映射用unordered_map, 真正的词用map
   其实这个方法好理解, 但是PQ这种数据结构/这里是最小堆, 也应该掌握 
   
347. Top K Frequent Elements: 直接使用默认的PQ，这个好理解; PQ仍然是类似pipeline只存K个元素, 多的从top移除
```````
🐷⚠️注意下面两种的区别: 
1. for (auto it = m.rbegin(); .. t= it->second : it用->获得元素, 因为it是迭代器
2. for (auto it : m) q.push({it.second...      : it用 .获得元素, 因为it是映射关系对象,并不是迭代器
```````
***🇨🇳重要:***********************
  
192. Word Frequency: (bash):

195. Tenth Line(bash): 

 
